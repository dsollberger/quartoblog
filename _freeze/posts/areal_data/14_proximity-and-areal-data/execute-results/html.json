{
  "hash": "3c61ee7644e927de8ce20b4917d0d756",
  "result": {
    "markdown": "# Proximity and Areal Data\n\n**Learning objectives:**\n\n* consider the definition of areal data\n* discuss matters of graph theory\n* explore various methods of finding neighbors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"dbscan\")     #density-based clustering\nlibrary(\"igraph\")     #graph networks\nlibrary(\"Matrix\")     #for sparse representation\nlibrary(\"sf\")         #simple features\nlibrary(\"spatialreg\") #spatial regression analysis\nlibrary(\"spdep\")      #spatial dependence\nlibrary(\"tmap\")       #quick, thematic maps\n\ndata(pol_pres15, package = \"spDataLarge\") #Poland 2015 election data\n\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] tmap_3.3-3       spdep_1.2-8      spatialreg_1.2-9 spData_2.2.2    \n[5] sf_1.0-14        Matrix_1.5-4     igraph_1.4.3     dbscan_1.1-11   \n\nloaded via a namespace (and not attached):\n [1] raster_3.6-23      xfun_0.40          htmlwidgets_1.6.2  lattice_0.21-8    \n [5] vctrs_0.6.3        tools_4.3.0        crosstalk_1.2.0    LearnBayes_2.15.1 \n [9] generics_0.1.3     parallel_4.3.0     sandwich_3.0-2     tibble_3.2.1      \n[13] proxy_0.4-27       fansi_1.0.4        pkgconfig_2.0.3    KernSmooth_2.23-20\n[17] RColorBrewer_1.1-3 leaflet_2.1.2      lifecycle_1.0.3    compiler_4.3.0    \n[21] deldir_1.0-9       terra_1.7-46       codetools_0.2-19   leafsync_0.1.0    \n[25] stars_0.6-3        htmltools_0.5.6    class_7.3-21       pillar_1.9.0      \n[29] MASS_7.3-58.4      classInt_0.4-10    lwgeom_0.2-13      wk_0.8.0          \n[33] boot_1.3-28.1      abind_1.4-5        multcomp_1.4-25    nlme_3.1-162      \n[37] tidyselect_1.2.0   digest_0.6.33      mvtnorm_1.2-0      dplyr_1.1.3       \n[41] splines_4.3.0      fastmap_1.1.1      grid_4.3.0         expm_0.999-7      \n[45] cli_3.6.1          magrittr_2.0.3     base64enc_0.1-3    dichromat_2.0-0.1 \n[49] XML_3.99-0.14      survival_3.5-5     utf8_1.2.3         leafem_0.2.0      \n[53] TH.data_1.1-2      e1071_1.7-13       sp_2.0-0           spDataLarge_2.0.9 \n[57] rmarkdown_2.24     png_0.1-8          zoo_1.8-12         coda_0.19-4       \n[61] evaluate_0.21      knitr_1.43         tmaptools_3.1-1    viridisLite_0.4.2 \n[65] s2_1.1.4           rlang_1.1.1        Rcpp_1.0.11        glue_1.6.2        \n[69] DBI_1.1.3          rstudioapi_0.15.0  jsonlite_1.8.7     R6_2.5.1          \n[73] units_0.8-3       \n```\n:::\n:::\n\n\n\n## Areal Data\n\n*Areal units* of observation are very often used when simultaneous observations are aggregated within non-overlapping boundaries. \n\n**Example:** Lung cancer SIR (standardized incidence rate) in Pennsylvania\n\n![image credit: Paula Moraga](images/mapsirs-1.png)\n\n## Proximity Data\n\nBy *proximity*, we mean closeness in ways that make sense for the data generation processes thought to be involved. In cross-sectional geostatistical analysis with point support, measured distance makes sense for typical data generation processes.\n\n**Example:** Voronoi diagram of Pennsylvania\n\n![image credit: John Nerbonne](images/Pennsylvania_voronoi.png)\n\n## Support\n\nBy *support* of data we mean the physical size (length, area, volume) associated with an individual observational unit\n\n* It is possible to represent the support of areal data by a point, despite the fact that the data have polygonal support\n* When the intrinsic support of the data is represented as points, but the underlying process is **between proximate observations** rather than driven chiefly by distance between observations\n* risk of misrepresenting the footprint of the underlying spatial processes\n\n## Representing Proximity\n\nIdeas for spatial autocorrelation\n\n* (graph theory) undirected graph, and its neighbors, or\n* (geospatial) variogram\n\nBut what about\n\n* islands?\n* disconnected subgraphs?\n* sparse areas (cutoff by distance threshold)\n\n## spdep package\n\n`spdep` package: [spatial dependence](https://cran.r-project.org/web/packages/spdep/index.html)\n\n* `nb` class for neighbor\n\n    - list of length `0L` for no neighbors\n\n* `listw` object\n\n    1. `nb` object\n    2. list of numerical weights\n    3. how the weights were calculated\n    \n* `spatialreg` package now has the functions for constructing and handling neighbour and spatial weights objects, tests for spatial autocorrelation, and model fitting functions that used to be in `spdep`\n\n    \n## Example: Poland 2015 Election\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15 |>\n    subset(select = c(TERYT, name, types)) |>\n    head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 6 features and 3 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 235157.1 ymin: 366913.3 xmax: 281431.7 ymax: 413016.6\nProjected CRS: ETRS89 / Poland CS92\n   TERYT                name       types                       geometry\n1 020101         BOLESŁAWIEC       Urban MULTIPOLYGON (((261089.5 38...\n2 020102         BOLESŁAWIEC       Rural MULTIPOLYGON (((254150 3837...\n3 020103            GROMADKA       Rural MULTIPOLYGON (((275346 3846...\n4 020104        NOWOGRODZIEC Urban/rural MULTIPOLYGON (((251769.8 37...\n5 020105          OSIECZNICA       Rural MULTIPOLYGON (((263423.9 40...\n6 020106 WARTA BOLESŁAWIECKA       Rural MULTIPOLYGON (((267030.7 38...\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# tmap\ntm_shape(pol_pres15) + tm_fill(\"types\")\n```\n\n::: {.cell-output-display}\n![](14_proximity-and-areal-data_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nFor safety’s sake, we impose topological validity:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!all(st_is_valid(pol_pres15)))\n        pol_pres15 <- st_make_valid(pol_pres15)\n```\n:::\n\n\n\n## Contiguous Neighbors\n\nFor each observation, the `poly2nb` function checks whether\n\n* at least one (`queen = TRUE`)\n* at least two (\"rook\", `queen = FALSE`)\n\npoints are within `snap` distance of each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15 |> poly2nb(queen = TRUE) -> nb_q\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(nb_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 2495 \nNumber of nonzero links: 14242 \nPercentage nonzero weights: 0.2287862 \nAverage number of links: 5.708216 \n```\n:::\n:::\n\n\n* `s2` spherical coordinates are used by default\n* symmetric relationships assumed\n* `row.names` may be customized\n\n### Connected\n\nAre the data connected? (Some model estimation techniques do not support graphs that are not connected.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_q |> n.comp.nb())$nc\n# result: 1 for TRUE (more than one for FALSE)\n```\n:::\n\n\n<details>\n<summary>verbose code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\n#library(Matrix, warn.conflicts = FALSE)\n#library(spatialreg, warn.conflicts = FALSE)\nnb_q |> \n    nb2listw(style = \"B\") |> \n    as(\"CsparseMatrix\") -> smat\n#library(igraph, warn.conflicts = FALSE)\nsmat |> graph.adjacency() -> g1\n\ng1 |> count_components()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n</details>\n\n\n## Graph-Based Neighbors\n\nThe simplest form is by using triangulation, here using the `deldir` package\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get centroids and save their coordinates\npol_pres15 |> \n    st_geometry() |> \n    st_centroid(of_largest_polygon = TRUE) -> coords \n\n# triangulation\n(coords |> tri2nb() -> nb_tri)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 2495 \nNumber of nonzero links: 14930 \nPercentage nonzero weights: 0.2398384 \nAverage number of links: 5.983968 \n```\n:::\n:::\n\n\n### How Far Away are the Neighbors?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# results in meters\nnb_tri |> \n    nbdists(coords) |> \n    unlist() |> \n    summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n   246.6   9847.2  12151.2  13485.2  14993.5 296973.7 \n```\n:::\n:::\n\n\n### Sphere of Influence\n\nThe Sphere of Influence `soi.graph` function takes triangulated neighbours and prunes off neighbour relationships represented by edges that are unusually long for each point.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_tri |> \n        soi.graph(coords) |> \n        graph2nb() -> nb_soi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNeighbour list object:\nNumber of regions: 2495 \nNumber of nonzero links: 12792 \nPercentage nonzero weights: 0.2054932 \nAverage number of links: 5.127054 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Poland\npol_pres15 |> \n    st_geometry() |> \n    plot(border = \"grey\", lwd = 0.5)\n```\n\n::: {.cell-output-display}\n![](14_proximity-and-areal-data_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# triangulation\nplot(nb_tri, \n     coords = coords, points = FALSE, lwd = 0.5)\n```\n\n::: {.cell-output-display}\n![](14_proximity-and-areal-data_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# sphere of influence\nplot(nb_soi, \n     coords = coords, points = FALSE, lwd = 0.5)\n```\n\n::: {.cell-output-display}\n![](14_proximity-and-areal-data_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n## Distance-Based Neighbors\n\n* Distance-based neighbours can be constructed using `dnearneigh`, with a distance band with lower `d1=` and upper `d2=` bounds controlled by the `bounds=` argument\n* The `knearneigh` function for -nearest neighbours returns a `knn` object, converted to an `nb` object using `knn2nb`\n* Computation speed boost through `dbscan` package\n* The `nbdists` function returns the length of neighbour relationship edges\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> \n    knearneigh(k = 1) |> \n    knn2nb() |> \n    nbdists(coords) |> \n    unlist() |> \n    summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  246.5  6663.4  8538.0  8275.1 10123.9 17978.8 \n```\n:::\n:::\n\n\nHere the largest first nearest neighbour distance is just under 18 km, so using this as the upper threshold gives certainty that all units will have at least one neighbour.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# maybe no neighbors\ncoords |> dnearneigh(0, 16000) -> nb_d16\n\n# at least one neighbor\ncoords |> dnearneigh(0, 18000) -> nb_d18\n```\n:::\n\n\n* Adding 300 m to the threshold gives us a neighbour object with no no-neighbour units, and all units can be reached from all others across the graph.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# connected graph\ncoords |> dnearneigh(0, 18300) -> nb_d183\n```\n:::\n\n\nIt is possible to control the numbers of neighbours directly using -nearest neighbours, either accepting asymmetric neighbours\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords |> knearneigh(k = 6) -> knn_k6\n\n# asymmetrical\nknn_k6 |> knn2nb() -> nb_k6\n\n# symmetrical\nknn_k6 |> knn2nb(sym = TRUE) -> nb_k6s\n```\n:::\n\n\n## Weights Specification\n\nOnce neighbour objects are available, further choices need to be made in specifying the weights objects. \n\n* The `nb2listw` function is used to create a `listw` weights object with an `nb` object, a matching list of weights vectors, and a style specification\n* Because handling no-neighbour observations now begins to matter, the `zero.policy=` argument is introduced (default: `FALSE`)\n* `n`: number of observations\n* $S_{0}$: sum of weights\n\n\nThe \"B\" binary style gives a weight of unity to each neighbour relationship, and typically up-weights units with no boundaries on the edge of the study area, having a higher count of neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nb2listw(style = \"B\") -> lw_q_B\n\nlw_q_B |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select = c(n, S0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     n    S0\n1 2495 14242\n```\n:::\n:::\n\n\nThe \"W\" row-standardised style up-weights units around the edge of the study area that necessarily have fewer neighbours. This style first gives a weight of unity to each neighbour relationship, then it divides these weights by the per unit sums of weights (caution: avoid no-neighbors)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nb2listw(style = \"W\") -> lw_q_W\n\nlw_q_W |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select = c(n, S0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     n   S0\n1 2495 2495\n```\n:::\n:::\n\n\n### Inverse Distance Weights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_d183 |> \n    nbdists(coords) |> \n    lapply(function(x) 1/(x/1000)) -> gwts\n```\n:::\n\n\nNo-neighbour handling is by default to prevent the construction of a weights object, making the analyst take a position on how to proceed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_d183 |> nb2listw(glist=gwts, style=\"B\") -> lw_d183_idw_B) |> \n    spweights.constants() |> \n    data.frame() |> \n    subset(select=c(n, S0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     n       S0\n1 2495 1841.345\n```\n:::\n:::\n\n\nUse can be made of the `zero.policy=` argument to many functions used with `nb` and `listw` objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(nb_d16 |> \n    nb2listw(style=\"B\", zero.policy=TRUE) |> \n    spweights.constants(zero.policy=TRUE) |> \n    data.frame() |> \n    subset(select=c(n, S0)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     n    S0\n1 2488 15850\n```\n:::\n:::\n\n\n\n## Higher-Order Neighbors\n\nIf we wish to create an object showing to neighbours, where $i$ is a neighbour of $j$, and $j$ in turn is a neighbour of $k$, so taking two steps on the neighbour graph, we can use `nblag` (automatically removes $i$ to $i$ self-neighbours)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_q |> nblag(2) -> nb_q2\n```\n:::\n\n\nReturning to the graph representation of the same neighbour object, we can ask how many steps might be needed to traverse the graph?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nigraph::diameter(g1) #where g1 is a graph object\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 52\n```\n:::\n:::\n\n\nWe step out from each observation across the graph to establish the number of steps needed to reach each other observation by the shortest path (creating an $n \\times n$ matrix `sps`), once again finding the same maximum count.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng1 |> shortest.paths() -> sps\nsps |> apply(2, max) -> spmax\n\nspmax |> max()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 52\n```\n:::\n:::\n\n\nThe municipality with the maximum count is called Lutowiska, close to the Ukrainian border in the far south east of the country.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmr <- which.max(spmax)\npol_pres15$name0[mr]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Lutowiska\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npol_pres15$sps1 <- sps[,mr]\ntm_shape(pol_pres15) +\n          tm_fill(\"sps1\", title = \"Shortest path\\ncount\")\n```\n\n::: {.cell-output-display}\n![](14_proximity-and-areal-data_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n## Meeting Videos {-}\n\n### Cohort 1 {-}\n\n<iframe src=\"https://www.youtube.com/embed/URL\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n<details>\n<summary> Meeting chat log </summary>\n\n```\nLOG\n```\n</details>\n",
    "supporting": [
      "14_proximity-and-areal-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}