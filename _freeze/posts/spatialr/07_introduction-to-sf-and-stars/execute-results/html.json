{
  "hash": "fd3be34405451c0107dd21867acf425d",
  "result": {
    "markdown": "# Introduction to sf and stars\n\n![North Carolina counties](images/north-carolina-county-map.png)\n\n![Olinda, Brazil](images/depositphotos_88829102-stock-photo-olinda-pinned-on-a-map.png)]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"cubelyr\")\nlibrary(\"dplyr\") #data wrangling\nlibrary(\"MASS\")  #linear discriminant analysis\nlibrary(\"sf\")    #simple features\nlibrary(\"spDataLarge\") #contains Bristol data\nlibrary(\"stars\") #useful for rasters and data cubes\nlibrary(\"tidyr\") #pivoting\nlibrary(\"units\")\nlibrary(\"xts\")   #time series tools\n\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.0 (2023-04-21 ucrt)\nPlatform: x86_64-w64-mingw32/x64 (64-bit)\nRunning under: Windows 10 x64 (build 19045)\n\nMatrix products: default\n\n\nlocale:\n[1] LC_COLLATE=English_United States.utf8 \n[2] LC_CTYPE=English_United States.utf8   \n[3] LC_MONETARY=English_United States.utf8\n[4] LC_NUMERIC=C                          \n[5] LC_TIME=English_United States.utf8    \n\ntime zone: America/Los_Angeles\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] xts_0.13.1        zoo_1.8-12        units_0.8-2       tidyr_1.3.0      \n [5] stars_0.6-1       abind_1.4-5       spDataLarge_2.0.9 sf_1.0-13        \n [9] MASS_7.3-58.4     dplyr_1.1.2       cubelyr_1.0.2    \n\nloaded via a namespace (and not attached):\n [1] lwgeom_0.2-13      jsonlite_1.8.4     compiler_4.3.0     tidyselect_1.2.0  \n [5] Rcpp_1.0.10        parallel_4.3.0     fastmap_1.1.1      lattice_0.21-8    \n [9] R6_2.5.1           generics_0.1.3     classInt_0.4-9     knitr_1.43        \n[13] htmlwidgets_1.6.2  tibble_3.2.1       DBI_1.1.3          pillar_1.9.0      \n[17] rlang_1.1.1        utf8_1.2.3         xfun_0.39          cli_3.6.1         \n[21] magrittr_2.0.3     class_7.3-21       digest_0.6.31      grid_4.3.0        \n[25] rstudioapi_0.14    lifecycle_1.0.3    vctrs_0.6.2        KernSmooth_2.23-20\n[29] proxy_0.4-27       evaluate_0.21      glue_1.6.2         fansi_1.0.4       \n[33] e1071_1.7-13       rmarkdown_2.22     purrr_1.0.1        tools_4.3.0       \n[37] pkgconfig_2.0.3    htmltools_0.5.5   \n```\n:::\n:::\n\n\n\n## sf\n\n**sf** provides *simple feature*  access\n\n* replaces packages `sp`, `rgeos`, `rgdal`\n* interface with `tidyverse`\n* geometrical operations with GEOS or s2geometry\n* coordinate transformations\n\n**sf** objects have\n\n* `data.frame` or `tibble`\n* `sfc`: geometry list-column\n\n### Metadata\n\n* `sf_column`: the name of the (active) geometry column\n* `agr`: attribute-geometry relationship\n\n![how to read a summary of an sf object](images/sf_obj.png)\n\n## Example: North Carolina\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# reading in an sf object\nnc <- st_read(system.file(\"gpkg/nc.gpkg\", package = \"sf\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `nc.gpkg' from data source \n  `C:\\Users\\freex\\AppData\\Local\\R\\win-library\\4.3\\sf\\gpkg\\nc.gpkg' \n  using driver `GPKG'\nSimple feature collection with 100 features and 14 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965\nGeodetic CRS:  NAD27\n```\n:::\n:::\n\n\n### Subsetting\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc[2:5, 3:7] #records 2-5 and columns 3-7 \n```\n:::\n\n\n![subset of North Carolina](images/fig-fig57-1.png)\n\n<details>\n<summary>Code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nnc5 <- nc[1:5, ]\nnc7 <- nc[1:7, ]\nplot(st_geometry(nc7))\nplot(st_geometry(nc5), add = TRUE, border = \"brown\")\ncc = st_coordinates(st_centroid(st_geometry(nc7)))\ntext(cc, labels = 1:nrow(nc7), col = \"blue\")\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n</details>\n\n* the `drop` argument is by default `FALSE` meaning that the geometry column is always selected\n* selection with a spatial (`sf`, `sfc`, or `sfg`) object as first argument leads to selection of the features that *spatially intersect* with that object\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(i <- st_intersects(nc5, nc7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSparse geometry binary predicate list of length 5, where the predicate\nwas `intersects'\n 1: 1, 2\n 2: 1, 2, 3\n 3: 2, 3\n 4: 4, 7\n 5: 5, 6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nas.matrix(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]\n[1,]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[2,]  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[3,] FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n[4,] FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE\n[5,] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# The object i is of class sgbp (sparse geometrical binary predicate)\nclass(i)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"sgbp\" \"list\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmethods(class = \"sgbp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] as.data.frame as.matrix     coerce        dim           initialize   \n [6] Ops           print         show          slotsFromS3   t            \nsee '?methods' for accessing help and source code\n```\n:::\n:::\n\n\n## tidyverse\n\nPackage sf has `tidyverse`-style read and write functions, `read_sf` and `write_sf` that\n\n* return a tibble rather than a data.frame\n* do not print any output\n* overwrite existing data by default\n\nThe `dplyr`, `ggplot2`, and `tidyr` capabilities are probably familiar for this audience, but there are some extra considerations for `sf` data below.\n\n### summarise\n\nThe `summarise` method for sf objects has two special arguments:\n\n* `do_union` (default `TRUE`) determines whether grouped geometries are unioned on return, so that they form a valid geometry\n* `is_coverage` (default `FALSE`) in case the geometries grouped form a coverage (do not have overlaps), setting this to `TRUE` speeds up the unioning\n\n### filter\n\nWe can use `filter` for spatial predicates.  For example, to select all counties less than 50 km away from Orange County,\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# filters\norange <- nc |> dplyr::filter(NAME == \"Orange\")\nwd <- st_is_within_distance(nc, orange, \n                            units::set_units(50, km))\no50 <- nc |> dplyr::filter(lengths(wd) > 0)\n\n# plot\nog <- st_geometry(orange)\nbuf50 <- st_buffer(og, units::set_units(50, km))\nall <- c(buf50, st_geometry(o50))\nplot(st_geometry(o50), lwd = 2, extent = all)\nplot(og, col = 'orange', add = TRUE)\nplot(buf50, add = TRUE, col = NA, border = 'brown')\nplot(st_geometry(nc), add = TRUE, border = 'grey')\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n### distinct\n\nThe `distinct` method selects distinct records, where `st_equals` is used to evaluate distinctness of geometries.\n\n## Spatial Joins\n\n* The concepts of “left”, “right”, “inner”, or “full” joins remain\n\nWhen using spatial joins, each record may have several matched records ... A way to reduce this complexity may be to select from the matching records the one with the *largest overlap* with the target geometry.\n\n<details>\n<summary>Loading shapefile and grid</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.file(\"shape/nc.shp\", package=\"sf\") |> \n    read_sf() |>\n    st_transform('EPSG:2264') -> nc\ngr <- st_sf(\n         label = apply(expand.grid(1:10, LETTERS[10:1])[,2:1], 1, paste0, collapse = \"\"),\n         geom = st_make_grid(nc))\ngr$col <- sf.colors(10, categorical = TRUE, alpha = .3)\n# cut, to verify that NA's work out:\ngr <- gr[-(1:30),]\n```\n:::\n\n</details>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnc_j <- st_join(nc, gr, largest = TRUE)\n```\n:::\n\n\n![spatial join](images/fig-largest-1.png)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(2,1), mar = rep(0,4))\nplot(st_geometry(nc_j), border = 'grey')\nplot(st_geometry(gr), add = TRUE, col = gr$col)\ntext(st_coordinates(st_centroid(st_geometry(gr))), labels = gr$label, cex = .85)\n# the joined dataset:\nplot(st_geometry(nc_j), border = 'grey', col = nc_j$col)\ntext(st_coordinates(st_centroid(st_geometry(nc_j))), labels = nc_j$label, cex = .7)\nplot(st_geometry(gr), border = '#88ff88aa', add = TRUE)\n```\n:::\n\n</details>\n\n## Creation\n\nAn `sf` object can be created from scratch by\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- st_point(c(7.35, 52.42))\np2 <- st_point(c(7.22, 52.18))\np3 <- st_point(c(7.44, 52.19))\nsfc <- st_sfc(list(p1, p2, p3), crs = 'OGC:CRS84')\nst_sf(elev = c(33.2, 52.1, 81.2), \n      marker = c(\"Id01\", \"Id02\", \"Id03\"), geom = sfc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 3 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 7.22 ymin: 52.18 xmax: 7.44 ymax: 52.42\nGeodetic CRS:  WGS 84\n  elev marker               geom\n1 33.2   Id01 POINT (7.35 52.42)\n2 52.1   Id02 POINT (7.22 52.18)\n3 81.2   Id03 POINT (7.44 52.19)\n```\n:::\n:::\n\n\nConvenience functions\n\n* `st_sample`\n* `st_make_grid`\n* `st_interpoloate_aw`\n\n\n## Ellipsoidal Coordinates\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"POINT(50 50.1)\" |> st_as_sfc(crs = \"OGC:CRS84\") -> pt\n```\n:::\n\n\n![new versus old methods](images/fig-figs2-1.png)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\npar(mar = c(2.1, 2.1, 1.2, .5))\northo <- st_crs(\"+proj=ortho +lon_0=50 +lat_0=45\")\npol |> st_transform(ortho) |> plot(axes = TRUE, graticule = TRUE, \n                                   main = 's2geometry')\npt |> st_transform(ortho) |> plot(add = TRUE, pch = 16, col = 'red')\n# second plot:\nplot(pol, axes = TRUE, graticule = TRUE, main = 'GEOS')\nplot(pt, add = TRUE, pch = 16, col = 'red')\n```\n:::\n\n</details>\n\n\nBy default, `sf` uses geometrical operations from the `s2geometry` library, interfaced through the `s2` package\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"POLYGON((40 40, 60 40, 60 50, 40 50, 40 40))\" |>\n  st_as_sfc(crs = \"OGC:CRS84\") -> pol\nst_intersects(pt, pol) #TRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSparse geometry binary predicate list of length 1, where the predicate\nwas `intersects'\n 1: 1\n```\n:::\n:::\n\n\nIf one wants sf to use ellipsoidal coordinates as if they are Cartesian coordinates, the use of s2 can be switched off\n\n\n::: {.cell}\n\n```{.r .cell-code}\nold <- sf_use_s2(FALSE)\n# Spherical geometry (s2) switched off\nst_intersects(pol, pt)\n# although coordinates are longitude/latitude, st_intersects assumes\n# that they are planar\n# Sparse geometry binary predicate list of length 1, where the\n# predicate was `intersects'\n#  1: (empty)\nsf_use_s2(old) # restore\n# Spherical geometry (s2) switched on\n```\n:::\n\n\n## stars\n\n* For the classic GIS view of raster layers, `terra` package\n\nCapabilities of `stars` include\n\n\n* allows for representing dynamic (time varying) **raster stacks**\n* aims at being *scalable*, also beyond local disk size\n* provides a strong integration of raster functions in the `GDAL` library\n* handles, in addition to regular grids, rotated, sheared, rectilinear, and **curvilinear rasters**\n* provides a tight integration with package `sf`\n* handles array data with non-raster spatial dimensions, the vector **data cubes**\n* follows the `tidyverse` design principles\n\n## Example: Olinda, Brazil\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr <- read_stars(system.file(\"tif/L7_ETMs.tif\", package = \"stars\"))\nr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 3 dimensions and 1 attribute\nattribute(s):\n             Min. 1st Qu. Median     Mean 3rd Qu. Max.\nL7_ETMs.tif     1      54     69 68.91242      86  255\ndimension(s):\n     from  to  offset delta                     refsys point x/y\nx       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\nband    1   6      NA    NA                         NA    NA    \n```\n:::\n:::\n\n\n<details>\n<summary>attributes</summary>\n\n* `from`: starting index\n* `to`: ending index\n* `offset`: dimension value at the start (edge) of the first pixel\n* `delta`: cell size; negative delta values indicate that pixel index increases with decreasing dimension values\n* `refsys`: reference system\n* `point`: logical, indicates whether cell values have point support or cell support\n* `x/y`: indicates whether a dimension is associated with a spatial raster x- or y-axis\n\n</details>\n\n### Plots\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1, 2))\nplot(r, rgb = c(3,2,1), reset = FALSE, main = \"RGB\")    # rgb\nplot(r, rgb = c(4,3,2), main = \"False colour (NIR-R-G)\") # false colour\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n### Subsetting\n\nExample: selects from `r`\n\n* attributes 1-2, index 101-200 for dimension 1, and index 5-10 for dimension 3\n* omitting dimension 2 means that no subsetting takes place\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[1:2, 101:200,, 5:10]\n```\n:::\n\n\nSelecting discontinuous ranges is supported only when it is a regular sequence\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[,1:100, seq(1, 250, 5), 4] |> dim() #default behavior\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   x    y band \n 100   50    1 \n```\n:::\n\n```{.r .cell-code}\nr[,1:100, seq(1, 250, 5), 4, drop = TRUE] |> dim()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x   y \n100  50 \n```\n:::\n:::\n\n\nFor selecting particular ranges of dimension values, one can use `dplyr::filter`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(r, x > 289000, x < 290000)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 3 dimensions and 1 attribute\nattribute(s):\n             Min. 1st Qu. Median    Mean 3rd Qu. Max.\nL7_ETMs.tif     5      51     63 64.3337      75  242\ndimension(s):\n     from  to  offset delta                     refsys point x/y\nx       1  35  289004  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\nband    1   6       1     1                         NA    NA    \n```\n:::\n:::\n\n\nor `slice`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslice(r, band, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n             Min. 1st Qu. Median     Mean 3rd Qu. Max.\nL7_ETMs.tif    21      49     63 64.35886      77  255\ndimension(s):\n  from  to  offset delta                     refsys point x/y\nx    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\n```\n:::\n:::\n\n\n### Cropping\n\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- st_bbox(r) |>\n    st_as_sfc() |>\n    st_centroid() |>\n    st_buffer(units::set_units(500, m))\nr[b]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 3 dimensions and 1 attribute\nattribute(s):\n             Min. 1st Qu. Median     Mean 3rd Qu. Max. NA's\nL7_ETMs.tif    22      54     66 67.68302   78.25  174 2184\ndimension(s):\n     from  to  offset delta                     refsys point x/y\nx     157 193  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny     159 194 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\nband    1   6      NA    NA                         NA    NA    \n```\n:::\n:::\n\n\n![Circular centre region of the Landsat 7 scene (band 1)](images/fig-circr-1.png)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r[b][,,,1], reset = FALSE)\nplot(b, border = 'brown', lwd = 2, col = NA, add = TRUE)\n```\n:::\n\n\nBy default, the resulting raster is cropped to the extent of the selection object; otherwise\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr[b, crop = FALSE]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 3 dimensions and 1 attribute\nattribute(s):\n             Min. 1st Qu. Median     Mean 3rd Qu. Max.   NA's\nL7_ETMs.tif    22      54     66 67.68302   78.25  174 731280\ndimension(s):\n     from  to  offset delta                     refsys point x/y\nx       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\nband    1   6      NA    NA                         NA    NA    \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can reset dimension offsets\nr[b] |> st_normalize() |> st_dimensions()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     from to  offset delta                     refsys point x/y\nx       1 37  293222  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny       1 36 9116258 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\nband    1  6      NA    NA                         NA    NA    \n```\n:::\n:::\n\n\n</details>\n\nor simply using the `stars` function made for cropping\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crop(r, b)\n```\n:::\n\n\n## Redimensioning\n\n* `aperm`: transposes an array by permuting the order of dimensions\n* Attributes and dimensions can be swapped, using `split` and `merge`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(rs <- split(r))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 6 attributes\nattribute(s):\n    Min. 1st Qu. Median     Mean 3rd Qu. Max.\nX1    47      67     78 79.14772      89  255\nX2    32      55     66 67.57465      79  255\nX3    21      49     63 64.35886      77  255\nX4     9      52     63 59.23541      75  255\nX5     1      63     89 83.18266     112  255\nX6     1      32     60 59.97521      88  255\ndimension(s):\n  from  to  offset delta                     refsys point x/y\nx    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmerge(rs, name = \"band\") |> setNames(\"L7_ETMs\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 3 dimensions and 1 attribute\nattribute(s):\n         Min. 1st Qu. Median     Mean 3rd Qu. Max.\nL7_ETMs     1      54     69 68.91242      86  255\ndimension(s):\n     from  to  offset delta                     refsys point    values x/y\nx       1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE      NULL [x]\ny       1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE      NULL [y]\nband    1   6      NA    NA                         NA    NA X1,...,X6    \n```\n:::\n:::\n\n\n* Multiple `stars` object with identical dimensions can be combined using `c`\n\n## Extraction\n\nA very common use case for raster data cube analysis is the extraction of values at certain locations, or computing aggregations over certain geometries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(115517)\npts <- st_bbox(r) |> st_as_sfc() |> st_sample(20)\n(e <- st_extract(r, pts))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n             Min. 1st Qu. Median     Mean 3rd Qu. Max.\nL7_ETMs.tif    12   41.75     63 60.95833    80.5  145\ndimension(s):\n         from to                     refsys point\ngeometry    1 20 SIRGAS 2000 / UTM zone 25S  TRUE\nband        1  6                         NA    NA\n                                                        values\ngeometry POINT (293002.2 9115516),...,POINT (290941.1 9114128)\nband                                                      NULL\n```\n:::\n:::\n\n\n## Predictive Models\n\n![Randomly chosen sample locations for training data; red: water, yellow: land](images/fig-rsample-1.png)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(r[,,,1], reset = FALSE)\ncol <- rep(\"yellow\", 20)\ncol[c(8, 14, 15, 18, 19)] = \"red\"\nst_as_sf(e) |> st_coordinates() |> text(labels = 1:20, col = col)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrs <- split(r)\ntrn <- st_extract(rs, pts)\ntrn$cls <- rep(\"land\", 20)\ntrn$cls[c(8, 14, 15, 18, 19)] <- \"water\"\nmodel <- MASS::lda(cls ~ ., st_drop_geometry(trn)) #linear discriminant analysis\npr <- predict(rs, model)\nplot(pr[1], key.pos = 4, key.width = lcm(3.5), key.length = lcm(2))\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\n## Computations\n\n* logarithmic transformation: `log(r)`\n* mask:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2 <- r\nr2[r < 50] <- NA\n```\n:::\n\n\n* unmask:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr2[is.na(r2)] <- 0\n```\n:::\n\n\n\n## Aggregation\n\nDimension-wise, we can apply functions to selected array dimensions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(r, c(\"x\", \"y\"), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n      Min.  1st Qu.   Median     Mean 3rd Qu. Max.\nmean  25.5 53.33333 68.33333 68.91242      82  255\ndimension(s):\n  from  to  offset delta                     refsys point x/y\nx    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\n```\n:::\n:::\n\n\nExample: NDVI (normalised differenced vegetation index)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi <- function(b1, b2, b3, b4, b5, b6) (b4 - b3)/(b4 + b3)\nst_apply(r, c(\"x\", \"y\"), ndvi)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n            Min.    1st Qu.      Median        Mean   3rd Qu.      Max.\nndvi  -0.7534247 -0.2030075 -0.06870229 -0.06432464 0.1866667 0.5866667\ndimension(s):\n  from  to  offset delta                     refsys point x/y\nx    1 349  288776  28.5 SIRGAS 2000 / UTM zone 25S FALSE [x]\ny    1 352 9120761 -28.5 SIRGAS 2000 / UTM zone 25S FALSE [y]\n```\n:::\n:::\n\n\n\nAggregation over a **temporal dimension** is done by passing a time variable as the second argument to `aggregate`, as a\n\n* set of time stamps indicating the start of time intervals,\n* set of time intervals defined by `make_intervals`, or\n* time period like `\"weeks\"`, `\"5 days\"`, or `\"years\"`.\n\n\n## Example: Air Quality\n\nWe use a small excerpt from the European air quality data base to illustrate aggregation operations on vector data cubes. The same data source was used by Gräler, Pebesma, and Heuvelink (2016)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(\"data/air.rda\")\nde_nuts1 <- read_sf(\"data/de_nuts1.gpkg\")\ndim(air)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspace  time \n   70  4383 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstations |>\n    st_as_sf(coords = c(\"longitude\", \"latitude\"), crs = 4326) |>\n    st_geometry() -> st\nd <- st_dimensions(station = st, time = dates)\n(aq <- st_as_stars(list(PM10 = air), dimensions = d))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n      Min. 1st Qu. Median     Mean 3rd Qu.    Max.   NA's\nPM10     0   9.921 14.792 17.69728  21.992 274.333 157659\ndimension(s):\n        from   to     offset  delta refsys point\nstation    1   70         NA     NA WGS 84  TRUE\ntime       1 4383 1998-01-01 1 days   Date FALSE\n                                                         values\nstation POINT (9.585911 53.67057),...,POINT (9.446661 49.24068)\ntime                                                       NULL\n```\n:::\n:::\n\n\n![sparse space-time diagram of PM10 measurements by time and station](images/fig-airst-1.png)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mar = c(5.1, 4.1, 0.3, 0.1))\nimage(aperm(log(aq), 2:1), main = NULL)\n```\n:::\n\n</details>\n\n![](images/fig-airmap-1)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nst_as_sf(st_apply(aq, 1, mean, na.rm = TRUE)) |>\n    plot(reset = FALSE, pch = 16, extent = de_nuts1)\nst_union(de_nuts1) |> plot(add = TRUE)\n```\n:::\n\n</details>\n\nExample: aggregate these station time series to area means\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(a <- aggregate(aq, de_nuts1, mean, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n        Min. 1st Qu.   Median     Mean  3rd Qu.     Max.  NA's\nPM10  1.0752 10.8855 15.31625 17.88823 21.81086 172.2665 25679\ndimension(s):\n     from   to     offset  delta refsys point\ngeom    1   16         NA     NA WGS 84 FALSE\ntime    1 4383 1998-01-01 1 days   Date FALSE\n                                                            values\ngeom MULTIPOLYGON (((9.65046 4...,...,MULTIPOLYGON (((10.77189 ...\ntime                                                          NULL\n```\n:::\n:::\n\n\nExample:  show the maps for six arbitrarily chosen days\n\n\n::: {.cell}\n\n```{.r .cell-code}\na |> filter(time >= \"2008-01-01\", time < \"2008-01-07\") |> \n    plot(key.pos = 4)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nExample: time series plot of mean values for a single state\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(as.xts(a)[,4], main = de_nuts1$NAME_1[4])\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n:::\n\n\n\n## Example: Transportation\n\n![Origin destination data zones for Bristol, UK, with zone 33 (E02003043) coloured red](images/fig-bristol1-1.png)\n\n<details>\n<summary>image code</summary>\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(st_geometry(bristol_zones), axes = TRUE, graticule = TRUE)\nplot(st_geometry(bristol_zones)[33], col = 'red', add = TRUE)\n```\n:::\n\n</details>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(bristol_od)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 7\n  o         d           all bicycle  foot car_driver train\n  <chr>     <chr>     <dbl>   <dbl> <dbl>      <dbl> <dbl>\n1 E02002985 E02002985   209       5   127         59     0\n2 E02002985 E02002987   121       7    35         62     0\n3 E02002985 E02003036    32       2     1         10     1\n4 E02002985 E02003043   141       1     2         56    17\n5 E02002985 E02003049    56       2     4         36     0\n6 E02002985 E02003054    42       4     0         21     0\n```\n:::\n:::\n\n\n### Preprocessing\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create O-D-mode array:\nbristol_tidy <- bristol_od |> \n    dplyr::select(-all) |> #caution: MASS also has select()\n    pivot_longer(3:6, names_to = \"mode\", values_to = \"n\")\nhead(bristol_tidy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n  o         d         mode           n\n  <chr>     <chr>     <chr>      <dbl>\n1 E02002985 E02002985 bicycle        5\n2 E02002985 E02002985 foot         127\n3 E02002985 E02002985 car_driver    59\n4 E02002985 E02002985 train          0\n5 E02002985 E02002987 bicycle        7\n6 E02002985 E02002987 foot          35\n```\n:::\n:::\n\n\nNext, we form the three-dimensional array\n\n* filled with zeroes (at first)\n* dimensions are named with the zone names (o, d) and the transportation mode name (mode)\n* ensure order of observations in `bristol_zones` and `bristol_tidy`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nod <- bristol_tidy |> pull(\"o\") |> unique()\nnod <- length(od)\nmode <- bristol_tidy |> pull(\"mode\") |> unique()\nnmode = length(mode)\na = array(0L,  c(nod, nod, nmode), \n    dimnames = list(o = od, d = od, mode = mode))\n\na[as.matrix(bristol_tidy[c(\"o\", \"d\", \"mode\")])] <-  bristol_tidy$n\n\norder <- match(od, bristol_zones$geo_code)\nzones <- st_geometry(bristol_zones)[order]\n```\n:::\n\n\n### stars object\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- st_dimensions(o = zones, d = zones, mode = mode)\nodm <- st_as_stars(list(N = a), dimensions = d)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# plot, sliced for destination zone 33\nplot(adrop(odm[,,33]) + 1, logz = TRUE)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n:::\n\n\nExample: largest number of travellers as its destination\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- st_apply(odm, 2, sum)\nwhich.max(d[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 33\n```\n:::\n:::\n\n\nExample: Total transportation by OD\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(odm, 1:2, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n     Min. 1st Qu. Median     Mean 3rd Qu. Max.\nsum     0       0      0 19.20636      19 1434\ndimension(s):\n  from  to refsys point\no    1 102 WGS 84 FALSE\nd    1 102 WGS 84 FALSE\n                                                         values\no MULTIPOLYGON (((-2.510462...,...,MULTIPOLYGON (((-2.55007 ...\nd MULTIPOLYGON (((-2.510462...,...,MULTIPOLYGON (((-2.55007 ...\n```\n:::\n:::\n\n\nExample: Origin totals, by mode\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(odm, c(1,3), sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n     Min. 1st Qu. Median     Mean 3rd Qu. Max.\nsum     1    57.5  214.5 489.7623     771 2903\ndimension(s):\n     from  to refsys point\no       1 102 WGS 84 FALSE\nmode    1   4     NA FALSE\n                                                            values\no    MULTIPOLYGON (((-2.510462...,...,MULTIPOLYGON (((-2.55007 ...\nmode                                             bicycle,...,train\n```\n:::\n:::\n\n\nExample: Destination totals, by mode\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_apply(odm, c(2,3), sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 1 attribute\nattribute(s):\n     Min. 1st Qu. Median     Mean 3rd Qu.  Max.\nsum     0      13  103.5 489.7623  408.25 12948\ndimension(s):\n     from  to refsys point\nd       1 102 WGS 84 FALSE\nmode    1   4     NA FALSE\n                                                            values\nd    MULTIPOLYGON (((-2.510462...,...,MULTIPOLYGON (((-2.55007 ...\nmode                                             bicycle,...,train\n```\n:::\n:::\n\n\nPlotting the origins and destinations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\no <- st_apply(odm, 1, sum)\nd <- st_apply(odm, 2, sum)\nx <- (c(o, d, along = list(od = c(\"origin\", \"destination\"))))\nplot(x, logz = TRUE)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n\n### Normalization\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- set_units(st_area(st_as_sf(o)), km^2)\no$sum_km <- o$sum / a\nd$sum_km <- d$sum / a\nod <- c(o[\"sum_km\"], d[\"sum_km\"], along = \n        list(od = c(\"origin\", \"destination\")))\nplot(od, logz = TRUE)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Total commutes per square km, by area of origin (left) or destination (right)\n```\n:::\n\n\n\n## Vector to Raster\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile <- system.file(\"gpkg/nc.gpkg\", package=\"sf\")\nread_sf(file) |> \n  st_geometry() |>\n  st_as_stars() |>\n  plot(key.pos = 4)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n:::\n\n\nRasterising existing features is done using `st_rasterize`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_sf(file) |>\n  dplyr::mutate(name = as.factor(NAME)) |>\n  dplyr::select(SID74, SID79, name) |>\n  st_rasterize()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nstars object with 2 dimensions and 3 attributes\nattribute(s):\n     SID74            SID79             name       \n Min.   : 0.000   Min.   : 0.000   Sampson :  655  \n 1st Qu.: 3.000   1st Qu.: 3.000   Columbus:  648  \n Median : 5.000   Median : 6.000   Robeson :  648  \n Mean   : 7.892   Mean   : 9.584   Bladen  :  604  \n 3rd Qu.:10.000   3rd Qu.:13.000   Wake    :  590  \n Max.   :44.000   Max.   :57.000   (Other) :30952  \n NA's   :30904    NA's   :30904    NA's    :30904  \ndimension(s):\n  from  to   offset      delta refsys point x/y\nx    1 461 -84.3239  0.0192484  NAD27 FALSE [x]\ny    1 141  36.5896 -0.0192484  NAD27 FALSE [y]\n```\n:::\n:::\n\n\nSimilarly, line and point geometries can be rasterised\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_sf(file) |>\n  st_cast(\"MULTILINESTRING\") |>\n  dplyr::select(CNTY_ID) |>\n  st_rasterize() |>\n  plot(key.pos = 4)\n```\n\n::: {.cell-output-display}\n![](07_introduction-to-sf-and-stars_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\n\n\n## Meeting Videos {-}\n\n### Cohort 1 {-}\n\n<iframe src=\"https://www.youtube.com/embed/URL\" width=\"100%\" height=\"400px\" data-external=\"1\"></iframe>\n\n<details>\n<summary> Meeting chat log </summary>\n\n```\nLOG\n```\n</details>\n",
    "supporting": [
      "07_introduction-to-sf-and-stars_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}